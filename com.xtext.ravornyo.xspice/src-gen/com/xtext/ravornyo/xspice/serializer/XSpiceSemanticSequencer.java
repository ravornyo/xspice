/*
 * generated by Xtext 2.18.0.M3
 */
package com.xtext.ravornyo.xspice.serializer;

import com.google.inject.Inject;
import com.xtext.ravornyo.xspice.services.XSpiceGrammarAccess;
import com.xtext.ravornyo.xspice.xSpice.ACSimulation;
import com.xtext.ravornyo.xspice.xSpice.AM;
import com.xtext.ravornyo.xspice.xSpice.BJT;
import com.xtext.ravornyo.xspice.xSpice.BJTModel;
import com.xtext.ravornyo.xspice.xSpice.CCCS;
import com.xtext.ravornyo.xspice.xSpice.CCVS;
import com.xtext.ravornyo.xspice.xSpice.Capacitor;
import com.xtext.ravornyo.xspice.xSpice.CapacitorModel;
import com.xtext.ravornyo.xspice.xSpice.Compilation;
import com.xtext.ravornyo.xspice.xSpice.CurrentExport;
import com.xtext.ravornyo.xspice.xSpice.CurrentSource;
import com.xtext.ravornyo.xspice.xSpice.CurrentSwitch;
import com.xtext.ravornyo.xspice.xSpice.CurrentSwitchModel;
import com.xtext.ravornyo.xspice.xSpice.DCSimulation;
import com.xtext.ravornyo.xspice.xSpice.DecadeSweep;
import com.xtext.ravornyo.xspice.xSpice.Diode;
import com.xtext.ravornyo.xspice.xSpice.DiodeModel;
import com.xtext.ravornyo.xspice.xSpice.Exp;
import com.xtext.ravornyo.xspice.xSpice.Inductor;
import com.xtext.ravornyo.xspice.xSpice.InitialCondition;
import com.xtext.ravornyo.xspice.xSpice.JFET;
import com.xtext.ravornyo.xspice.xSpice.JFETModel;
import com.xtext.ravornyo.xspice.xSpice.LinearSweep;
import com.xtext.ravornyo.xspice.xSpice.MOSFET;
import com.xtext.ravornyo.xspice.xSpice.MOSFETModel;
import com.xtext.ravornyo.xspice.xSpice.MutualInductance;
import com.xtext.ravornyo.xspice.xSpice.NodeSet;
import com.xtext.ravornyo.xspice.xSpice.NodeSetEntry;
import com.xtext.ravornyo.xspice.xSpice.NoiseSimulation;
import com.xtext.ravornyo.xspice.xSpice.OctaveSweep;
import com.xtext.ravornyo.xspice.xSpice.Options;
import com.xtext.ravornyo.xspice.xSpice.PWL;
import com.xtext.ravornyo.xspice.xSpice.ParameterSweep;
import com.xtext.ravornyo.xspice.xSpice.Plot;
import com.xtext.ravornyo.xspice.xSpice.Print;
import com.xtext.ravornyo.xspice.xSpice.Pulse;
import com.xtext.ravornyo.xspice.xSpice.Resistor;
import com.xtext.ravornyo.xspice.xSpice.ResistorModel;
import com.xtext.ravornyo.xspice.xSpice.SFFM;
import com.xtext.ravornyo.xspice.xSpice.Simulation;
import com.xtext.ravornyo.xspice.xSpice.Sine;
import com.xtext.ravornyo.xspice.xSpice.SubCircuit;
import com.xtext.ravornyo.xspice.xSpice.SubCircuitDefinition;
import com.xtext.ravornyo.xspice.xSpice.TransientSimulation;
import com.xtext.ravornyo.xspice.xSpice.VCCS;
import com.xtext.ravornyo.xspice.xSpice.VCVS;
import com.xtext.ravornyo.xspice.xSpice.VSource;
import com.xtext.ravornyo.xspice.xSpice.VoltageExport;
import com.xtext.ravornyo.xspice.xSpice.VoltageSwitch;
import com.xtext.ravornyo.xspice.xSpice.VoltageSwitchModel;
import com.xtext.ravornyo.xspice.xSpice.XSpicePackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class XSpiceSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XSpiceGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == XSpicePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XSpicePackage.AC_SIMULATION:
				sequence_ACSimulation(context, (ACSimulation) semanticObject); 
				return; 
			case XSpicePackage.AM:
				sequence_AM(context, (AM) semanticObject); 
				return; 
			case XSpicePackage.BJT:
				sequence_BJT(context, (BJT) semanticObject); 
				return; 
			case XSpicePackage.BJT_MODEL:
				sequence_BJTModel(context, (BJTModel) semanticObject); 
				return; 
			case XSpicePackage.CCCS:
				sequence_CCCS(context, (CCCS) semanticObject); 
				return; 
			case XSpicePackage.CCVS:
				sequence_CCVS(context, (CCVS) semanticObject); 
				return; 
			case XSpicePackage.CAPACITOR:
				sequence_Capacitor(context, (Capacitor) semanticObject); 
				return; 
			case XSpicePackage.CAPACITOR_MODEL:
				sequence_CapacitorModel(context, (CapacitorModel) semanticObject); 
				return; 
			case XSpicePackage.COMPILATION:
				sequence_Compilation(context, (Compilation) semanticObject); 
				return; 
			case XSpicePackage.CURRENT_EXPORT:
				sequence_CurrentExport(context, (CurrentExport) semanticObject); 
				return; 
			case XSpicePackage.CURRENT_SOURCE:
				sequence_CurrentSource(context, (CurrentSource) semanticObject); 
				return; 
			case XSpicePackage.CURRENT_SWITCH:
				sequence_CurrentSwitch(context, (CurrentSwitch) semanticObject); 
				return; 
			case XSpicePackage.CURRENT_SWITCH_MODEL:
				sequence_CurrentSwitchModel(context, (CurrentSwitchModel) semanticObject); 
				return; 
			case XSpicePackage.DC_SIMULATION:
				sequence_DCSimulation(context, (DCSimulation) semanticObject); 
				return; 
			case XSpicePackage.DECADE_SWEEP:
				sequence_DecadeSweep(context, (DecadeSweep) semanticObject); 
				return; 
			case XSpicePackage.DIODE:
				sequence_Diode(context, (Diode) semanticObject); 
				return; 
			case XSpicePackage.DIODE_MODEL:
				sequence_DiodeModel(context, (DiodeModel) semanticObject); 
				return; 
			case XSpicePackage.EXP:
				sequence_Exp(context, (Exp) semanticObject); 
				return; 
			case XSpicePackage.INDUCTOR:
				sequence_Inductor(context, (Inductor) semanticObject); 
				return; 
			case XSpicePackage.INITIAL_CONDITION:
				sequence_InitialCondition(context, (InitialCondition) semanticObject); 
				return; 
			case XSpicePackage.JFET:
				sequence_JFET(context, (JFET) semanticObject); 
				return; 
			case XSpicePackage.JFET_MODEL:
				sequence_JFETModel(context, (JFETModel) semanticObject); 
				return; 
			case XSpicePackage.LINEAR_SWEEP:
				sequence_LinearSweep(context, (LinearSweep) semanticObject); 
				return; 
			case XSpicePackage.MOSFET:
				sequence_MOSFET(context, (MOSFET) semanticObject); 
				return; 
			case XSpicePackage.MOSFET_MODEL:
				sequence_MOSFETModel(context, (MOSFETModel) semanticObject); 
				return; 
			case XSpicePackage.MUTUAL_INDUCTANCE:
				sequence_MutualInductance(context, (MutualInductance) semanticObject); 
				return; 
			case XSpicePackage.NODE_SET:
				sequence_NodeSet(context, (NodeSet) semanticObject); 
				return; 
			case XSpicePackage.NODE_SET_ENTRY:
				sequence_NodeSetEntry(context, (NodeSetEntry) semanticObject); 
				return; 
			case XSpicePackage.NOISE_SIMULATION:
				sequence_NoiseSimulation(context, (NoiseSimulation) semanticObject); 
				return; 
			case XSpicePackage.OCTAVE_SWEEP:
				sequence_OctaveSweep(context, (OctaveSweep) semanticObject); 
				return; 
			case XSpicePackage.OPTIONS:
				sequence_Options(context, (Options) semanticObject); 
				return; 
			case XSpicePackage.PWL:
				sequence_PWL(context, (PWL) semanticObject); 
				return; 
			case XSpicePackage.PARAMETER_SWEEP:
				sequence_ParameterSweep(context, (ParameterSweep) semanticObject); 
				return; 
			case XSpicePackage.PLOT:
				sequence_Plot(context, (Plot) semanticObject); 
				return; 
			case XSpicePackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case XSpicePackage.PULSE:
				sequence_Pulse(context, (Pulse) semanticObject); 
				return; 
			case XSpicePackage.RESISTOR:
				sequence_Resistor(context, (Resistor) semanticObject); 
				return; 
			case XSpicePackage.RESISTOR_MODEL:
				sequence_ResistorModel(context, (ResistorModel) semanticObject); 
				return; 
			case XSpicePackage.SFFM:
				sequence_SFFM(context, (SFFM) semanticObject); 
				return; 
			case XSpicePackage.SIMULATION:
				sequence_Simulation(context, (Simulation) semanticObject); 
				return; 
			case XSpicePackage.SINE:
				sequence_Sine(context, (Sine) semanticObject); 
				return; 
			case XSpicePackage.SUB_CIRCUIT:
				sequence_SubCircuit(context, (SubCircuit) semanticObject); 
				return; 
			case XSpicePackage.SUB_CIRCUIT_DEFINITION:
				sequence_SubCircuitDefinition(context, (SubCircuitDefinition) semanticObject); 
				return; 
			case XSpicePackage.TRANSIENT_SIMULATION:
				sequence_TransientSimulation(context, (TransientSimulation) semanticObject); 
				return; 
			case XSpicePackage.VCCS:
				sequence_VCCS(context, (VCCS) semanticObject); 
				return; 
			case XSpicePackage.VCVS:
				sequence_VCVS(context, (VCVS) semanticObject); 
				return; 
			case XSpicePackage.VSOURCE:
				sequence_VSource(context, (VSource) semanticObject); 
				return; 
			case XSpicePackage.VOLTAGE_EXPORT:
				sequence_VoltageExport(context, (VoltageExport) semanticObject); 
				return; 
			case XSpicePackage.VOLTAGE_SWITCH:
				sequence_VoltageSwitch(context, (VoltageSwitch) semanticObject); 
				return; 
			case XSpicePackage.VOLTAGE_SWITCH_MODEL:
				sequence_VoltageSwitchModel(context, (VoltageSwitchModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Simulation returns ACSimulation
	 *     ACSimulation returns ACSimulation
	 *
	 * Constraint:
	 *     sweep=GeometericSweep
	 */
	protected void sequence_ACSimulation(ISerializationContext context, ACSimulation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.AC_SIMULATION__SWEEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.AC_SIMULATION__SWEEP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getACSimulationAccess().getSweepGeometericSweepParserRuleCall_1_0(), semanticObject.getSweep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Waveform returns AM
	 *     AM returns AM
	 *
	 * Constraint:
	 *     (args+=NUMBER args+=NUMBER*)
	 */
	protected void sequence_AM(ISerializationContext context, AM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns BJTModel
	 *     BJTModel returns BJTModel
	 *
	 * Constraint:
	 *     (
	 *         name=Label 
	 *         (
	 *             saturationCurrent=NUMBER | 
	 *             betaF=NUMBER | 
	 *             emissionCoefficientForward=NUMBER | 
	 *             earlyVoltageForward=NUMBER | 
	 *             rollOffForward=NUMBER | 
	 *             leakBeCurrent=NUMBER | 
	 *             leakBeEmissionCoefficient=NUMBER | 
	 *             betaR=NUMBER | 
	 *             emissionCoefficientReverse=NUMBER | 
	 *             earlyVoltageReverse=NUMBER | 
	 *             rollOffReverse=NUMBER | 
	 *             leakBcCurrent=NUMBER | 
	 *             leakBcEmissionCoefficient=NUMBER | 
	 *             baseResist=NUMBER | 
	 *             baseCurrentHalfResist=NUMBER | 
	 *             minimumBaseResistance=NUMBER | 
	 *             emitterResistance=NUMBER | 
	 *             collectorResistance=NUMBER | 
	 *             depletionCapBe=NUMBER | 
	 *             potentialBe=NUMBER | 
	 *             junctionExpBe=NUMBER | 
	 *             transitTimeForward=NUMBER | 
	 *             transitTimeBiasCoefficientForward=NUMBER | 
	 *             transitTimeForwardVoltageBc=NUMBER | 
	 *             transitTimeHighCurrentForward=NUMBER | 
	 *             excessPhase=NUMBER | 
	 *             depletionCapBc=NUMBER | 
	 *             potentialBc=NUMBER | 
	 *             junctionExpBc=NUMBER | 
	 *             baseFractionBcCap=NUMBER | 
	 *             transitTimeReverse=NUMBER | 
	 *             capCs=NUMBER | 
	 *             potentialSubstrate=NUMBER | 
	 *             exponentialSubstrate=NUMBER | 
	 *             betaExponent=NUMBER | 
	 *             energyGap=NUMBER | 
	 *             tempExpIs=NUMBER | 
	 *             flickerNoiseCoefficient=NUMBER | 
	 *             flickerNoiseExponent=NUMBER | 
	 *             depletionCapCoefficient=NUMBER | 
	 *             nominalTemperature=NUMBER
	 *         )*
	 *     )
	 */
	protected void sequence_BJTModel(ISerializationContext context, BJTModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns BJT
	 *     Component returns BJT
	 *     BJT returns BJT
	 *
	 * Constraint:
	 *     (
	 *         (name=QNID | name=QPID) 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE? 
	 *         model=Label 
	 *         ((area=NUMBER | off?='OFF' | temp=NUMBER)? (ic+=NUMBER ic+=NUMBER)?)+
	 *     )
	 */
	protected void sequence_BJT(ISerializationContext context, BJT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns CCCS
	 *     Component returns CCCS
	 *     CCCS returns CCCS
	 *
	 * Constraint:
	 *     (name=FID nodes+=NODE nodes+=NODE controller=VID gain=NUMBER)
	 */
	protected void sequence_CCCS(ISerializationContext context, CCCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns CCVS
	 *     Component returns CCVS
	 *     CCVS returns CCVS
	 *
	 * Constraint:
	 *     (name=HID nodes+=NODE nodes+=NODE controller=VID transresistance=NUMBER)
	 */
	protected void sequence_CCVS(ISerializationContext context, CCVS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns CapacitorModel
	 *     CapacitorModel returns CapacitorModel
	 *
	 * Constraint:
	 *     (
	 *         name=Label 
	 *         (
	 *             junctionCap=NUMBER | 
	 *             junctionCapSidewall=NUMBER | 
	 *             defaultWidth=NUMBER | 
	 *             narrow=NUMBER | 
	 *             temperatureCoefficient1=NUMBER | 
	 *             temperatureCoefficient2=NUMBER | 
	 *             nominalTemperature=NUMBER
	 *         )*
	 *     )
	 */
	protected void sequence_CapacitorModel(ISerializationContext context, CapacitorModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Capacitor
	 *     Component returns Capacitor
	 *     Capacitor returns Capacitor
	 *
	 * Constraint:
	 *     (
	 *         name=CID 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         capacitance=NUMBER? 
	 *         model=Label? 
	 *         (length=NUMBER | width=NUMBER)* 
	 *         initialCondition=NUMBER?
	 *     )
	 */
	protected void sequence_Capacitor(ISerializationContext context, Capacitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Compilation returns Compilation
	 *
	 * Constraint:
	 *     (
	 *         definitions+=SubCircuitDefinition | 
	 *         entities+=Entity | 
	 *         simulations+=Simulation | 
	 *         outputs+=Output | 
	 *         options+=Options | 
	 *         ic+=InitialCondition | 
	 *         nodeset+=NodeSet
	 *     )*
	 */
	protected void sequence_Compilation(ISerializationContext context, Compilation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Export returns CurrentExport
	 *     CurrentExport returns CurrentExport
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             prefix='I' | 
	 *             prefix='IM' | 
	 *             prefix='IDB' | 
	 *             prefix='IP' | 
	 *             prefix='IR' | 
	 *             prefix='II'
	 *         ) 
	 *         nodes+=Label
	 *     )
	 */
	protected void sequence_CurrentExport(ISerializationContext context, CurrentExport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns CurrentSource
	 *     Component returns CurrentSource
	 *     CurrentSource returns CurrentSource
	 *
	 * Constraint:
	 *     (
	 *         name=IID 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         dc=NUMBER? 
	 *         (ac+=NUMBER ac+=NUMBER?)? 
	 *         waveform=Waveform?
	 *     )
	 */
	protected void sequence_CurrentSource(ISerializationContext context, CurrentSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns CurrentSwitchModel
	 *     CurrentSwitchModel returns CurrentSwitchModel
	 *
	 * Constraint:
	 *     (name=Label (threshold=NUMBER | hysteresis=NUMBER | onResistance=NUMBER | offResistance=NUMBER)+)
	 */
	protected void sequence_CurrentSwitchModel(ISerializationContext context, CurrentSwitchModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns CurrentSwitch
	 *     Component returns CurrentSwitch
	 *     CurrentSwitch returns CurrentSwitch
	 *
	 * Constraint:
	 *     (
	 *         name=WID 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         controllingSource=IID 
	 *         model=Label 
	 *         zeroState?='ON'?
	 *     )
	 */
	protected void sequence_CurrentSwitch(ISerializationContext context, CurrentSwitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Simulation returns DCSimulation
	 *     DCSimulation returns DCSimulation
	 *
	 * Constraint:
	 *     (sweeps+=ParameterSweep sweeps+=ParameterSweep*)
	 */
	protected void sequence_DCSimulation(ISerializationContext context, DCSimulation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeometericSweep returns DecadeSweep
	 *     DecadeSweep returns DecadeSweep
	 *
	 * Constraint:
	 *     (initial=NUMBER final=NUMBER pointsPerDecade=NUMBER)
	 */
	protected void sequence_DecadeSweep(ISerializationContext context, DecadeSweep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__INITIAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__INITIAL));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__FINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__FINAL));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.DECADE_SWEEP__POINTS_PER_DECADE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.DECADE_SWEEP__POINTS_PER_DECADE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecadeSweepAccess().getInitialNUMBERTerminalRuleCall_1_0(), semanticObject.getInitial());
		feeder.accept(grammarAccess.getDecadeSweepAccess().getFinalNUMBERTerminalRuleCall_2_0(), semanticObject.getFinal());
		feeder.accept(grammarAccess.getDecadeSweepAccess().getPointsPerDecadeNUMBERTerminalRuleCall_3_0(), semanticObject.getPointsPerDecade());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns DiodeModel
	 *     DiodeModel returns DiodeModel
	 *
	 * Constraint:
	 *     (
	 *         name=Label 
	 *         (
	 *             saturationCurrent=NUMBER | 
	 *             resistance=NUMBER | 
	 *             emissionCoefficient=NUMBER | 
	 *             transitTime=NUMBER | 
	 *             junctionCap=NUMBER | 
	 *             junctionPotential=NUMBER | 
	 *             gradingCoefficient=NUMBER | 
	 *             activationEnergy=NUMBER | 
	 *             saturationCurrentExp=NUMBER | 
	 *             flickerNoiseCoefficient=NUMBER | 
	 *             flickerNoiseExponent=NUMBER | 
	 *             depletionCapCoefficient=NUMBER | 
	 *             breakdownVoltage=NUMBER | 
	 *             breakdownCurrent=NUMBER | 
	 *             nominalTemperature=NUMBER
	 *         )*
	 *     )
	 */
	protected void sequence_DiodeModel(ISerializationContext context, DiodeModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Diode
	 *     Component returns Diode
	 *     Diode returns Diode
	 *
	 * Constraint:
	 *     (name=DID nodes+=NODE nodes+=NODE model=Label (area=NUMBER | off?='OFF' | ic=NUMBER | temp=NUMBER)*)
	 */
	protected void sequence_Diode(ISerializationContext context, Diode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Waveform returns Exp
	 *     Exp returns Exp
	 *
	 * Constraint:
	 *     (args+=NUMBER args+=NUMBER*)
	 */
	protected void sequence_Exp(ISerializationContext context, Exp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Inductor
	 *     Component returns Inductor
	 *     Inductor returns Inductor
	 *
	 * Constraint:
	 *     (name=LID nodes+=NODE nodes+=NODE inductance=NUMBER initialCondition=NUMBER?)
	 */
	protected void sequence_Inductor(ISerializationContext context, Inductor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialCondition returns InitialCondition
	 *
	 * Constraint:
	 *     (entries+=NodeSetEntry entries+=NodeSetEntry*)
	 */
	protected void sequence_InitialCondition(ISerializationContext context, InitialCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns JFETModel
	 *     JFETModel returns JFETModel
	 *
	 * Constraint:
	 *     (
	 *         name=Label 
	 *         (
	 *             threshold=NUMBER | 
	 *             beta=NUMBER | 
	 *             lambda=NUMBER | 
	 *             drainResistance=NUMBER | 
	 *             sourceResistance=NUMBER | 
	 *             capGs=NUMBER | 
	 *             capGd=NUMBER | 
	 *             gatePotential=NUMBER | 
	 *             gateSaturationCurrent=NUMBER | 
	 *             b=NUMBER | 
	 *             flickerNoiseCoefficient=NUMBER | 
	 *             flickerNoiseExponent=NUMBER | 
	 *             depletionCapCoefficient=NUMBER | 
	 *             nominalTemperature=NUMBER
	 *         )*
	 *     )
	 */
	protected void sequence_JFETModel(ISerializationContext context, JFETModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns JFET
	 *     Component returns JFET
	 *     JFET returns JFET
	 *
	 * Constraint:
	 *     (
	 *         (name=TNID | name=TPID) 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         model=Label 
	 *         ((area=NUMBER | off?='OFF' | temp=NUMBER)? (ic+=NUMBER ic+=NUMBER)?)+
	 *     )
	 */
	protected void sequence_JFET(ISerializationContext context, JFET semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeometericSweep returns LinearSweep
	 *     LinearSweep returns LinearSweep
	 *
	 * Constraint:
	 *     (initial=NUMBER final=NUMBER delta=NUMBER)
	 */
	protected void sequence_LinearSweep(ISerializationContext context, LinearSweep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__INITIAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__INITIAL));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__FINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__FINAL));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.LINEAR_SWEEP__DELTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.LINEAR_SWEEP__DELTA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinearSweepAccess().getInitialNUMBERTerminalRuleCall_1_0(), semanticObject.getInitial());
		feeder.accept(grammarAccess.getLinearSweepAccess().getFinalNUMBERTerminalRuleCall_2_0(), semanticObject.getFinal());
		feeder.accept(grammarAccess.getLinearSweepAccess().getDeltaNUMBERTerminalRuleCall_3_0(), semanticObject.getDelta());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns MOSFETModel
	 *     MOSFETModel returns MOSFETModel
	 *
	 * Constraint:
	 *     (
	 *         name=Label 
	 *         (
	 *             level=DIGIT | 
	 *             vt0=NUMBER | 
	 *             transconductance=NUMBER | 
	 *             gamma=NUMBER | 
	 *             phi=NUMBER | 
	 *             lambda=NUMBER | 
	 *             drainResistance=NUMBER | 
	 *             sourceResistance=NUMBER | 
	 *             capBd=NUMBER | 
	 *             capBs=NUMBER | 
	 *             junctionSatCur=NUMBER | 
	 *             bulkJunctionPotential=NUMBER | 
	 *             gateSourceOverlapCapFactor=NUMBER | 
	 *             gateDrainOverlapCapFactor=NUMBER | 
	 *             gateBulkOverlapCapFactor=NUMBER | 
	 *             sheetResistance=NUMBER | 
	 *             bulkCapFactor=NUMBER | 
	 *             bulkJunctionBotGradingCoefficient=NUMBER | 
	 *             sidewallCapFactor=NUMBER | 
	 *             bulkJunctionSideGradingCoefficient=NUMBER | 
	 *             junctionSatCurDensity=NUMBER | 
	 *             oxideThickness=NUMBER | 
	 *             substrateDoping=NUMBER | 
	 *             surfaceStateDensity=NUMBER | 
	 *             nfs=NUMBER | 
	 *             gateType='1' | 
	 *             gateType='0' | 
	 *             gateType='-1' | 
	 *             xj=NUMBER | 
	 *             lateralDiffusion=NUMBER | 
	 *             surfaceMobility=NUMBER | 
	 *             flickerNoiseCoefficient=NUMBER | 
	 *             flickerNoiseExponent=NUMBER | 
	 *             forwardCapDepletionCoefficient=NUMBER | 
	 *             nominalTemperature=NUMBER
	 *         )*
	 *     )
	 */
	protected void sequence_MOSFETModel(ISerializationContext context, MOSFETModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns MOSFET
	 *     Component returns MOSFET
	 *     MOSFET returns MOSFET
	 *
	 * Constraint:
	 *     (
	 *         (name=MNID | name=MPID) 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         model=Label 
	 *         (
	 *             (
	 *                 length=NUMBER | 
	 *                 width=NUMBER | 
	 *                 drainArea=NUMBER | 
	 *                 sourceArea=NUMBER | 
	 *                 drainPerimeter=NUMBER | 
	 *                 sourcePerimeter=NUMBER | 
	 *                 drainSquares=NUMBER | 
	 *                 sourceSquares=NUMBER | 
	 *                 off?='OFF' | 
	 *                 temp=NUMBER
	 *             )? 
	 *             (ic+=NUMBER ic+=NUMBER ic+=NUMBER)?
	 *         )+
	 *     )
	 */
	protected void sequence_MOSFET(ISerializationContext context, MOSFET semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns MutualInductance
	 *     MutualInductance returns MutualInductance
	 *
	 * Constraint:
	 *     (name=KID inductor1=LID inductor2=LID coupling=NUMBER)
	 */
	protected void sequence_MutualInductance(ISerializationContext context, MutualInductance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.ENTITY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.ENTITY__NAME));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.MUTUAL_INDUCTANCE__INDUCTOR1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.MUTUAL_INDUCTANCE__INDUCTOR1));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.MUTUAL_INDUCTANCE__INDUCTOR2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.MUTUAL_INDUCTANCE__INDUCTOR2));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.MUTUAL_INDUCTANCE__COUPLING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.MUTUAL_INDUCTANCE__COUPLING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMutualInductanceAccess().getNameKIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMutualInductanceAccess().getInductor1LIDTerminalRuleCall_1_0(), semanticObject.getInductor1());
		feeder.accept(grammarAccess.getMutualInductanceAccess().getInductor2LIDTerminalRuleCall_2_0(), semanticObject.getInductor2());
		feeder.accept(grammarAccess.getMutualInductanceAccess().getCouplingNUMBERTerminalRuleCall_3_0(), semanticObject.getCoupling());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeSetEntry returns NodeSetEntry
	 *
	 * Constraint:
	 *     (node+=NODE value=NUMBER)
	 */
	protected void sequence_NodeSetEntry(ISerializationContext context, NodeSetEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeSet returns NodeSet
	 *
	 * Constraint:
	 *     (entries+=NodeSetEntry entries+=NodeSetEntry*)
	 */
	protected void sequence_NodeSet(ISerializationContext context, NodeSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Simulation returns NoiseSimulation
	 *     NoiseSimulation returns NoiseSimulation
	 *
	 * Constraint:
	 *     (output+=Export inputSource=Label isweep=GeometericSweep)
	 */
	protected void sequence_NoiseSimulation(ISerializationContext context, NoiseSimulation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeometericSweep returns OctaveSweep
	 *     OctaveSweep returns OctaveSweep
	 *
	 * Constraint:
	 *     (initial=NUMBER final=NUMBER pointsPerOctave=NUMBER)
	 */
	protected void sequence_OctaveSweep(ISerializationContext context, OctaveSweep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__INITIAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__INITIAL));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__FINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.GEOMETERIC_SWEEP__FINAL));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.OCTAVE_SWEEP__POINTS_PER_OCTAVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.OCTAVE_SWEEP__POINTS_PER_OCTAVE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOctaveSweepAccess().getInitialNUMBERTerminalRuleCall_1_0(), semanticObject.getInitial());
		feeder.accept(grammarAccess.getOctaveSweepAccess().getFinalNUMBERTerminalRuleCall_2_0(), semanticObject.getFinal());
		feeder.accept(grammarAccess.getOctaveSweepAccess().getPointsPerOctaveNUMBERTerminalRuleCall_3_0(), semanticObject.getPointsPerOctave());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Options returns Options
	 *
	 * Constraint:
	 *     (
	 *         abstol=NUMBER | 
	 *         badmos3=NUMBER | 
	 *         chgtol=NUMBER | 
	 *         defad=NUMBER | 
	 *         defas=NUMBER | 
	 *         defl=NUMBER | 
	 *         defaultWidth=NUMBER | 
	 *         gmin=NUMBER | 
	 *         itl1=NUMBER | 
	 *         itl2=NUMBER | 
	 *         itl3=NUMBER | 
	 *         itl4=NUMBER | 
	 *         itl5=NUMBER | 
	 *         keepopinfo=NUMBER | 
	 *         method=IntegrationMethod | 
	 *         pivrel=NUMBER | 
	 *         reltol=NUMBER | 
	 *         temp=NUMBER | 
	 *         nominalTemperature=NUMBER | 
	 *         trtol=NUMBER | 
	 *         vntol=NUMBER
	 *     )+
	 */
	protected void sequence_Options(ISerializationContext context, Options semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Waveform returns PWL
	 *     PWL returns PWL
	 *
	 * Constraint:
	 *     (args+=NUMBER args+=NUMBER (args+=NUMBER args+=NUMBER)*)
	 */
	protected void sequence_PWL(ISerializationContext context, PWL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterSweep returns ParameterSweep
	 *
	 * Constraint:
	 *     (source=Label sweep=GeometericSweep)
	 */
	protected void sequence_ParameterSweep(ISerializationContext context, ParameterSweep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.PARAMETER_SWEEP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.PARAMETER_SWEEP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, XSpicePackage.Literals.PARAMETER_SWEEP__SWEEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XSpicePackage.Literals.PARAMETER_SWEEP__SWEEP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterSweepAccess().getSourceLabelParserRuleCall_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getParameterSweepAccess().getSweepGeometericSweepParserRuleCall_1_0(), semanticObject.getSweep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Output returns Plot
	 *     Plot returns Plot
	 *
	 * Constraint:
	 *     (prtype=PRTYPE exports+=Export exports+=Export*)
	 */
	protected void sequence_Plot(ISerializationContext context, Plot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Output returns Print
	 *     Print returns Print
	 *
	 * Constraint:
	 *     (prtype=PRTYPE exports+=Export exports+=Export*)
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Waveform returns Pulse
	 *     Pulse returns Pulse
	 *
	 * Constraint:
	 *     (args+=NUMBER args+=NUMBER*)
	 */
	protected void sequence_Pulse(ISerializationContext context, Pulse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns ResistorModel
	 *     ResistorModel returns ResistorModel
	 *
	 * Constraint:
	 *     (
	 *         name=Label 
	 *         (
	 *             sheetResistance=NUMBER | 
	 *             defaultWidth=NUMBER | 
	 *             narrow=NUMBER | 
	 *             temperatureCoefficient1=NUMBER | 
	 *             temperatureCoefficient2=NUMBER | 
	 *             nominalTemperature=NUMBER
	 *         )*
	 *     )
	 */
	protected void sequence_ResistorModel(ISerializationContext context, ResistorModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Resistor
	 *     Component returns Resistor
	 *     Resistor returns Resistor
	 *
	 * Constraint:
	 *     (
	 *         name=RID 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         resistance=NUMBER? 
	 *         model=Label? 
	 *         (length=NUMBER | width=NUMBER | temp=NUMBER)*
	 *     )
	 */
	protected void sequence_Resistor(ISerializationContext context, Resistor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Waveform returns SFFM
	 *     SFFM returns SFFM
	 *
	 * Constraint:
	 *     (args+=NUMBER args+=NUMBER*)
	 */
	protected void sequence_SFFM(ISerializationContext context, SFFM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Simulation returns Simulation
	 *
	 * Constraint:
	 *     {Simulation}
	 */
	protected void sequence_Simulation(ISerializationContext context, Simulation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Waveform returns Sine
	 *     Sine returns Sine
	 *
	 * Constraint:
	 *     (args+=NUMBER args+=NUMBER*)
	 */
	protected void sequence_Sine(ISerializationContext context, Sine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubCircuitDefinition returns SubCircuitDefinition
	 *
	 * Constraint:
	 *     (name=Label pins+=NODE pins+=NODE* (definitions+=SubCircuitDefinition | entities+=Entity)*)
	 */
	protected void sequence_SubCircuitDefinition(ISerializationContext context, SubCircuitDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns SubCircuit
	 *     SubCircuit returns SubCircuit
	 *
	 * Constraint:
	 *     (name=XID nodes+=NODE nodes+=NODE* definition=[SubCircuitDefinition|Label])
	 */
	protected void sequence_SubCircuit(ISerializationContext context, SubCircuit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Simulation returns TransientSimulation
	 *     TransientSimulation returns TransientSimulation
	 *
	 * Constraint:
	 *     (args+=NUMBER args+=NUMBER args+=NUMBER* uic?='UIC'?)
	 */
	protected void sequence_TransientSimulation(ISerializationContext context, TransientSimulation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns VCCS
	 *     Component returns VCCS
	 *     VCCS returns VCCS
	 *
	 * Constraint:
	 *     (
	 *         name=GID 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         transconductance=NUMBER
	 *     )
	 */
	protected void sequence_VCCS(ISerializationContext context, VCCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns VCVS
	 *     Component returns VCVS
	 *     VCVS returns VCVS
	 *
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         gain=NUMBER
	 *     )
	 */
	protected void sequence_VCVS(ISerializationContext context, VCVS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns VSource
	 *     Component returns VSource
	 *     VSource returns VSource
	 *
	 * Constraint:
	 *     (
	 *         name=VID 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         dc=NUMBER? 
	 *         (ac+=NUMBER ac+=NUMBER?)? 
	 *         waveform=Waveform?
	 *     )
	 */
	protected void sequence_VSource(ISerializationContext context, VSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Export returns VoltageExport
	 *     VoltageExport returns VoltageExport
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             prefix='V' | 
	 *             prefix='VM' | 
	 *             prefix='VDB' | 
	 *             prefix='VP' | 
	 *             prefix='VR' | 
	 *             prefix='VI'
	 *         ) 
	 *         nodes+=Label 
	 *         nodes+=NODE?
	 *     )
	 */
	protected void sequence_VoltageExport(ISerializationContext context, VoltageExport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns VoltageSwitchModel
	 *     VoltageSwitchModel returns VoltageSwitchModel
	 *
	 * Constraint:
	 *     (name=Label (threshold=NUMBER | hysteresis=NUMBER | onResistance=NUMBER | offResistance=NUMBER)+)
	 */
	protected void sequence_VoltageSwitchModel(ISerializationContext context, VoltageSwitchModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns VoltageSwitch
	 *     Component returns VoltageSwitch
	 *     VoltageSwitch returns VoltageSwitch
	 *
	 * Constraint:
	 *     (
	 *         name=SID 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         nodes+=NODE 
	 *         model=Label 
	 *         zeroState?='ON'?
	 *     )
	 */
	protected void sequence_VoltageSwitch(ISerializationContext context, VoltageSwitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
